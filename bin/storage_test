#!/bin/bash

# take the path of the storage device and test is it a block device.

function run_bonnie() {
    echo "Running bonnie++ on $1..."
    mount_point=$(df -h | grep -m 1 $1 | awk '{print $6}')
    echo "Putting scratch disk at $mount_point"
    mkdir -p "$mount_point/tmp/scratchdir"
    
    # When running on disks with small drives (SSD/flash) we need to do
    # some tweaking. Bonnie uses 2x RAM by default to write data. If that's 
    # more than available disk space, the test will fail inappropriately.
    free_space=$(df -m | grep -m 1 $1 | awk '{print $4}')
    echo "    Disk $1 has ${free_space}MB available"
    memory=$(free -m |grep Mem|awk '{print $2}')
    echo "    System has ${memory}MB RAM"
    disk_needed=$((memory * 2))
    echo "    We need ${disk_needed}MB of disk space for testing"
    if [[ "$disk_needed" -ge "$free_space" ]]; then
        echo "    Insufficient disk space available for defaults."
        echo "    reducing memory footprint to be 1/2 of free disk space."
        # we need to pass an amount that's 1/2 the amount of available disk
        # space to bonnie++ so she doesn't overwrite and fail.
        disk_needed=$(($free_space/2))
        bonnie++ -d $mount_point/tmp/scratchdir -u root -r $disk_needed
    else
        echo "   Free disk space is sufficient to continue testing."
        bonnie++ -d $mount_point/tmp/scratchdir -u root
    fi
}

# Find the largest partition that holds a supported filesystem on $disk_device.
# This code is adapted from a similar function in `disk_stress_ng`.
# Output:
#   $largest_part -- Device filename of largest qualifying partition or logical volume
#   $largest_size -- Size of largest qualifying partition or logical volume
#   $largest_fs -- Filesystem (ext4, etc.) used on largest qualifying partition or logical volume
#   $unsupported_fs -- Empty or contains name of unsupported filesystem found on disk
find_largest_partition() {
    largest_part=""
    largest_size=0
    partitions=$(lsblk -b -l -n -o NAME,SIZE,TYPE,MOUNTPOINT $disk | grep part | tr -s " ")
    unsupported_fs=""
    for partition in $(echo "$partitions" | cut -d " " -f 1) ; do
        part_size=$(echo "$partitions" | grep "$partition " | cut -d " " -f 2)
        local blkid_info=$(blkid -s TYPE /dev/$partition | grep -E ext2\|ext3\|ext4\|xfs\|jfs\|btrfs)
        if [ "$part_size" -gt "$largest_size" ] && [ -n "$blkid_info" ]  ; then
            largest_size=$part_size
            largest_part="/dev/$partition"
            largest_fs=$(blkid -s TYPE "/dev/$partition" | cut -d "=" -f 2)
        fi
        local blkid_info=$(blkid -s TYPE /dev/$partition | grep -E ntfs\|vfat\|hfs)
        if [ -n "$blkid_info" ]  ; then
            # If there's an NTFS, HFS+, or FAT filesystem on the disk make note of it....
            unsupported_fs=$(blkid -s TYPE "/dev/$partition" | cut -d "=" -f 2)
        fi
    done
} # find_largest_partition()

disk=/dev/$1
scripted_mount=0

if [ -b $disk ]
then
    echo "$disk is a block device"
    
    #Add a check for warnings
    WARN=$(parted -s ${disk} print | grep "^Warning.*${disk}.*[Rr]ead-only" 2>&1)
    if [[ $? == 0 ]]
    then
        echo "Warning found in parted output:"
        echo $WARN
        echo "Aborting Test"
        exit 1
    fi

    # Regex changed to better handle when $disk appears more than once
    # in parted output (such as in warning messages or not caught in the
    # check above)
    size=`parted -l -s |grep "Disk.*${disk}" |awk '{print $3}'`

    if [ -n "$size" ]
    then
        echo "$disk reports a size of $size."
        # Have to account for the end of the size descriptor
        size_range=${size:(-2)}
	
        if mount | grep -q $disk
        then
            echo "$disk is mounted, proceeding."
        else
            echo "$disk is not mounted. It must be mounted before testing."
            find_largest_partition
            if [ -n "$largest_part" ]
            then
                dest=`mktemp -dq --tmpdir drive.XXX`
                echo "Mounting $largest_part into $dest..."
                mount $largest_part $dest
                if [[ $? == 0 ]]
                then
                    scripted_mount=1
                fi
            else
                echo "$disk has no partition. Please format this drive and re-launch the test."
                exit 1
            fi
        fi


        if [ $size_range == "KB" ]
        then
            echo "$disk size reported in KB, seems to be too small for testing."
            exit 1
        elif [ $size_range == "MB" ]
        then
            size_int=${size::${#size}-2}

            if [ $size_int -gt 10 ]
            then
                run_bonnie $disk
                if [[ $scripted_mount == 1 ]]
                then
                    echo "$largest_part was mounted by this script. Unmounting it now..."
                    umount $largest_part
                    echo "Removing temporary mount directory $dest..."
                    rm -rf $dest
                fi
            else
                echo "$disk is too small to be used for testing."
                if [[ $scripted_mount == 1 ]]
                then
                    echo "$largest_part was mounted by this script. Unmounting it now..."
                    umount $largest_part
                    echo "Removing temporary mount directory $dest..."
                    rm -rf $dest
                fi
                exit 1
            fi
        else
            run_bonnie $disk
            if [[ $scripted_mount == 1 ]]
            then
                echo "$largest_part was mounted by this script. Unmounting it now..."
                umount $largest_part
                echo "Removing temporary mount directory $dest..."
                rm -rf $dest
            fi
        fi
    else
       echo "$disk doesn't report a size."
       exit 1
    fi
else
    echo "$disk is not listed as a block device."
    exit 1
fi
