#!/bin/bash

# take the path of the storage device and test is it a block device.

function run_bonnie() {
    echo "Running bonnie++ on $1..."
    mount_point=$(df -h | grep -m 1 $1 | awk '{print $6}')
    echo "Putting scratch disk at $mount_point"
    mkdir -p "$mount_point/tmp/scratchdir"
    
    # When running on disks with small drives (SSD/flash) we need to do
    # some tweaking. Bonnie uses 2x RAM by default to write data. If that's 
    # more than available disk space, the test will fail inappropriately.
    free_space=$(df -m | grep -m 1 $1 | awk '{print $4}')
    echo "    Disk $1 has ${free_space}MB available"
    memory=$(free -m |grep Mem|awk '{print $2}')
    echo "    System has ${memory}MB RAM"
    disk_needed=$((memory * 2))
    echo "    We need ${disk_needed}MB of disk space for testing"
    if [[ "$disk_needed" -ge "$free_space" ]]; then
        echo "    Insufficient disk space available for defaults."
        echo "    reducing memory footprint to be 1/2 of free disk space."
        # we need to pass an amount that's 1/2 the amount of available disk
        # space to bonnie++ so she doesn't overwrite and fail.
        disk_needed=$(($free_space/2))
        bonnie++ -d $mount_point/tmp/scratchdir -u root -r $disk_needed
    else
        echo "   Free disk space is sufficient to continue testing."
        bonnie++ -d $mount_point/tmp/scratchdir -u root
    fi
}

# Find the largest logical volume in an LVM partition.
# Output:
#   $largest_part -- Device filename of largest qualifying partition
#   $largest_size -- Size of largest qualifying partition
#   $largest_fs -- Filesystem (ext4, etc.) used on largest qualifying partition
# Note: Above variables are initialized in find_largest_partition(), which
# calls this function.
# Caveat: If LVM is used, there can be no guarantee that a specific disk
# device is actually being tested. Thus, an LVM configuration should span
# just one disk device. LVM may be used on one disk, but subsequent disks
# should use "raw" partitions.
find_largest_lv() {
    local partonly=$(echo $partition | cut -f 3 -d "/")
        for syslv in $(ls -d /sys/block/dm-*/slaves/$partonly) ; do
            lv=$(echo "$syslv" | cut -f 4 -d "/")
            size=$(cat /sys/block/$lv/size)
            sector_size=$(cat /sys/block/$lv/queue/hw_sector_size)
            let size=$size*$sector_size
            local blkid_info=$(blkid -s TYPE /dev/$lv | grep -E ext2\|ext3\|ext4\|xfs\|jfs\|btrfs)
            if [ "$size" -gt "$largest_size" ] && [ -n "$blkid_info" ] ; then
                local blkid_info=$(blkid -s TYPE /dev/$lv)
                largest_size=$size
                largest_part="/dev/$lv"
                largest_fs=$(blkid -s TYPE "/dev/$lv" | cut -d "=" -f 2)
            fi
        done
} # find_largest_lv()


# Find the largest partition that holds a supported filesystem on $disk_device.
# This code is adapted from a similar function in `disk_stress_ng`.
# Output:
#   $largest_part -- Device filename of largest qualifying partition or logical volume
#   $largest_size -- Size of largest qualifying partition or logical volume
#   $largest_fs -- Filesystem (ext4, etc.) used on largest qualifying partition or logical volume
#   $unsupported_fs -- Empty or contains name of unsupported filesystem found on disk
find_largest_partition() {
    largest_part=""
    largest_size=0
    mapper_string="dm-"
    if [ "${disk_device#*$mapper_string}" = "$disk_device" ]; then
        partitions=$(lsblk -b -l -n -o NAME,SIZE,TYPE,MOUNTPOINT $disk_device | grep part | tr -s " ")
    else
        partitions=$(lsblk -b -l -n -o NAME,SIZE,TYPE,MOUNTPOINT $disk_device)
    fi
    unsupported_fs=""
    for partition in $(echo "$partitions" | cut -d " " -f 1) ; do
        part_size=$(echo "$partitions" | grep "$partition " | cut -d " " -f 2)
        if [ -b "/dev/$partition" ]; then
            part_location="/dev/$partition"
        elif [ -b "/dev/mapper/$partition" ]; then
            part_location="/dev/mapper/$partition"
        else
            echo "$partition not found!"
            echo "Aborting test"
            exit 1
        fi
        local blkid_info=$(blkid -s TYPE $part_location | grep -E ext2\|ext3\|ext4\|xfs\|jfs\|btrfs\|LVM2_member)
        if [ "$part_size" > "$largest_size" ] && [ -n "$blkid_info" ]  ; then
            if [[ "$blkid_info" =~ .*LVM2_member.* ]] ; then
                find_largest_lv
            else
                largest_size=$part_size
                largest_part="$part_location"
                largest_fs=$(blkid -s TYPE "$part_location" | cut -d "=" -f 2)
            fi
        fi
        local blkid_info=$(blkid -s TYPE $part_location | grep -E ntfs\|vfat\|hfs)
	if [ -n "$blkid_info" ]  ; then
	    # If there's an NTFS, HFS+, or FAT filesystem on the disk make note of it....
	    unsupported_fs=$(blkid -s TYPE "/dev/$partition" | cut -d "=" -f 2)
	fi
     done
} # find_largest_partition()


if [[ "$1}" =~ dm-.* ]]; then
    # assume lvm or multipath and look for the dev/mapper device
    disk=/dev/mapper/`ls -l /dev/mapper/ | grep $1 | awk '{print $9}'`
else
    # if the disk doesn't look like dm-0
    disk=/dev/$1
fi
echo "Set disk to $disk"
scripted_mount=0

if [ -b $disk ]
then
    echo "$disk is a block device"
    
    #Add a check for warnings
    WARN=$(parted -s ${disk} print | grep "^Warning.*${disk}.*[Rr]ead-only" 2>&1)
    if [[ $? == 0 ]]
    then
        echo "Warning found in parted output:"
        echo $WARN
        echo "Aborting Test"
        exit 1
    fi

    # Regex changed to better handle when $disk appears more than once
    # in parted output (such as in warning messages or not caught in the
    # check above)
    size=`parted -l -s |grep "Disk.*${disk}" |awk '{print $3}'`

    if [ -n "$size" ]
    then
        echo "$disk reports a size of $size."
        # Have to account for the end of the size descriptor
        size_range=${size:(-2)}
	
        if mount | grep -q $disk
        then
            echo "$disk is mounted, proceeding."
        else
            echo "$disk is not mounted. It must be mounted before testing."
            find_largest_partition
            if [ -n "$largest_part" ]
            then
                dest=`mktemp -dq --tmpdir drive.XXX`
                echo "Mounting $largest_part into $dest..."
                mount $largest_part $dest
                if [[ $? == 0 ]]
                then
                    scripted_mount=1
                fi
            else
                echo "$disk has no partition. Please format this drive and re-launch the test."
                exit 1
            fi
        fi


        if [ $size_range == "KB" ]
        then
            echo "$disk size reported in KB, seems to be too small for testing."
            exit 1
        elif [ $size_range == "MB" ]
        then
            size_int=${size::${#size}-2}

            if [ $size_int -gt 10 ]
            then
                run_bonnie $disk
                if [[ $scripted_mount == 1 ]]
                then
                    echo "$largest_part was mounted by this script. Unmounting it now..."
                    umount $largest_part
                    echo "Removing temporary mount directory $dest..."
                    rm -rf $dest
                fi
            else
                echo "$disk is too small to be used for testing."
                if [[ $scripted_mount == 1 ]]
                then
                    echo "$largest_part was mounted by this script. Unmounting it now..."
                    umount $largest_part
                    echo "Removing temporary mount directory $dest..."
                    rm -rf $dest
                fi
                exit 1
            fi
        else
            run_bonnie $disk
            if [[ $scripted_mount == 1 ]]
            then
                echo "$largest_part was mounted by this script. Unmounting it now..."
                umount $largest_part
                echo "Removing temporary mount directory $dest..."
                rm -rf $dest
            fi
        fi
    else
       echo "$disk doesn't report a size."
       exit 1
    fi
else
    echo "$disk is not listed as a block device."
    exit 1
fi
